        - ### Vector/Collections API
        - 
        - function vcat(x::RLEVector, y::RLEVector)
        2   RLEVector( vcat(x.runvalues, y.runvalues), vcat(x.runends, y.runends + length(x)))
        - end
        - 
        - function pop!(x::RLEVector)
        1   runcount = nrun(x)
        1   isempty(x) && throw(ArgumentError("array must be non-empty"))
        1   item = x.runvalues[end]
        1   x.runends[end] -= 1
        1   if x.runends[end] == 0
        0     deleteat!(x.runvalues,runcount)
        0     deleteat!(x.runends,runcount)
        -   end
        1   return(item)
        - end
        - 
        - function push!{T,T2 <: Integer}(x::RLEVector{T,T2},item)
        2   item = convert(T,item) # Copying how base does it for arrays
        2   if item == x.runvalues[end]
        0     x.runends[end] += 1
        -   else
        2     push!(x.runvalues,item)
        2     push!(x.runends,x.runends[end]+1)
        -   end
        2   return(x)
        - end
        - 
        - function shift!(x::RLEVector)
        1   isempty(x) && throw(ArgumentError("array must be non-empty"))
        1   item = x.runvalues[1]
        1   x.runends -= 1
        1   if x.runends[1] == 0
        0     deleteat!(x.runvalues,1)
        0     deleteat!(x.runends,1)
        -   end
        1   return(item)
        - end
        - 
        - function shove!{T,T2 <: Integer}(x::RLEVector{T,T2},item)
        1   item = convert(T,item) # Copying how base does it for arrays
        1   x.runends += 1
        1   if item != x.runvalues[1]
        1     unshift!(x.runvalues,item)
        1     unshift!(x.runends,1)
        -   end
        1   return(x)
        - end
        - unshift!{T,T2 <: Integer}(x::RLEVector{T,T2},item) = shove(x,item) # Does unshift come from perl? Isn't Larry Wall a linguist? C'mon!
        - 
        - function insert!{T,T2 <: Integer}(x::RLEVector{T,T2},i::Integer,item)
        6   if i == length(x) + 1
        1     push!(x,item)
        1     return(x)
        -   end
        5   if i < 1 || i > length(x)
        2     throw(BoundsError())
        -   end
        3   (run, index_in_run, run_remainder) = ind2runcontext(x,i)
        3   if item == x.runvalues[run]
        0     x.runends[run:end] += 1
        -   else
        3     if index_in_run == 1
        2       ins_vals = [item; x.runvalues[run]]
        2       ins_ends = [i; x.runends[run]+1]
        -     else
        1       ins_vals = [x.runvalues[run]; item; x.runvalues[run]]
        1       ins_ends = [i-1; i; x.runends[run]+1]
        -     end
        3     x.runvalues = vcat( x.runvalues[1:run-1], ins_vals, x.runvalues[run+1:end] )
        3     x.runends = vcat( x.runends[1:run-1], ins_ends, x.runends[run+1:end] + 1 )
        -   end
        3   x.runvalues,x.runends = ree(x.runvalues,x.runends)
        3   return(x)
        - end
        - 
        - function deleterun!(x::RLEVector,i::Integer)
        5   x.runends[i:end] -= rwidth(x,i)
        5   if (i > 1 && i < nrun(x) && x.runvalues[i-1] == x.runvalues[i+1])
        1     splice!(x.runvalues,(i-1):i)
        1     splice!(x.runends,(i-1):i)
        -   else
        4     deleteat!(x.runvalues,i)
        4     deleteat!(x.runends,i)
        -   end
        5   return(x)
        - end
        - 
        - function decrement_run!(x::RLEVector,run::Integer)
        8   if rwidth(x,run) == 1
        1     deleterun!(x,run)
        -   else
        7     x.runends[run:end] -= 1
        -   end
        8   return(x)
        - end
        - 
        - function deleteat!(x::RLEVector,i::Integer)
        5   run = ind2run(x,i)
        5   decrement_run!(x,run)
        - end
        - 
        - _default_splice = RLEVector(Union{}[],Int64[])
        - function splice!(x::RLEVector, i::Integer, ins::RLEVector=_default_splice)
       13   if i < 1 || i > length(x)
        0     throw(BoundsError())
        -   end
       10   if length(ins) == 0
        3     run = ind2run(x,i)
        3     current = x.runvalues[run]
        3     decrement_run!(x,run)
        -   else
        7     (run, index_in_run, run_remainder) = ind2runcontext(x,i)
        7     current = x.runvalues[run]
        7     right_shift = length(ins) - length(i)
        7     x.runends[run:end] += right_shift
        7     ins.runends += (i-1)
        7     if index_in_run == 1
        5       ins_vals = [ins.runvalues; x.runvalues[run]]
        5       ins_ends = [ins.runends; x.runends[run]]
        -     else
        2       ins_vals = [x.runvalues[run]; ins.runvalues; x.runvalues[run]]
        2       ins_ends = [i-1; ins.runends; x.runends[run]]
        -     end
        7     x.runvalues = vcat( x.runvalues[1:run-1], ins_vals, x.runvalues[run+1:end] )
        7     x.runends = vcat( x.runends[1:run-1], ins_ends, x.runends[run+1:end])
        7     x.runvalues,x.runends = ree(x.runvalues,x.runends)
        -   end
       10   return(current)
        - end
        - 
        - function splice!(x::RLEVector, index::Range, ins::RLEVector=_default_splice) # Can I do index::Union(Integer,UnitRange) here to have just one method?
        3   i_left = start(index)
        3   i_right = last(index)
        3   if i_left < 1 || i_right > length(x)
        0     throw(BoundsError())
        -   end
        3   if length(index) == 0
        3   current = similar(x,0)
        3   (run_right, index_in_run_right, run_remainder_right) = (run_left, index_in_run_left, run_remainder_left) = ind2runcontext(x,i_left)
        -   else
        0     current = x[index]
        0     (run_left, index_in_run_left, run_remainder_left) = ind2runcontext(x,i_left)
        0     (run_right, index_in_run_right, run_remainder_right) = ind2runcontext(x,i_right)
        -   end
        3   ins.runends += (i_left - 1)
        3   right_shift = nrun(ins) - length(index)
        3   x.runends[run_right:end] += right_shift
        3   if index_in_run_left == 1
        2     ins_vals = [ins.runvalues; x.runvalues[run_right]]
        2     ins_ends = [ins.runends; x.runends[run_right]]
        -   else
        1     ins_vals = [x.runvalues[run_left]; ins.runvalues; x.runvalues[run_right]]
        1     ins_ends = [i_left-1; ins.runends; x.runends[run_right]]
        -   end
        3   x.runvalues = vcat( x.runvalues[1:run_left-1], ins_vals, x.runvalues[run_right+1:end] )
        3   x.runends = vcat( x.runends[1:run_left-1], ins_ends, x.runends[run_right+1:end] )
        3   x.runvalues, x.runends = ree(x.runvalues,x.runends)
        3   return(current)
        - end
        - 
        - function splice!(x::RLEVector, i::Integer, ins::AbstractArray)
        6   splice!(x,i,RLEVector(ins))
        - end
        - 
        - function splice!(x::RLEVector, i::Range, ins::AbstractArray)
        3   splice!(x,i,RLEVector(ins))
        - end
        - 
        - # Appended space initialized with zero unlike base array
        - function resize!(x::RLEVector, nl::Integer) # Based on base version for array
        2   l = length(x)
        2   if nl > l
        1     push!(x.runends,nl)
        1     push!(x.runvalues,0)
        -   else
        1     nl < 0 && throw(ArgumentError("new length must be â‰¥ 0"))
        1     (run, index_in_run, run_remainder) = ind2runcontext(x,nl)
        1     x.runends = x.runends[1:run]
        1     x.runends[end] = x.runends[end] - run_remainder
        1     x.runvalues = x.runvalues[1:run]
        -   end
        2   return(x)
        - end
        - 
        - function empty!(x::RLEVector)
        1   empty!(x.runvalues)
        1   empty!(x.runends)
        1   return(x)
        - end
        - 
