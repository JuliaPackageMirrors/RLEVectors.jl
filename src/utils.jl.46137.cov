        - 
        - # Like R's rep, repeat
        - #  No length_out arg at this time
        - function rep(x::Union{Any,Vector}; each::Union{Int,Vector{Int}} = ones(Int,length(x)), times::Int = 1)
        5   if !isa(x,Vector)
        0     x = [ x ]
        -   end
        5   if isa(each,Int)
        3     each = [ each for i in eachindex(x) ]
        -   end
        5   length(x) != length(each) && throw(ArgumentError("If the arguemnt 'each' is not a scalar, it must have the same length as 'x'."))
        4   length_out = sum(each * times)
        4   rval = similar(x,length_out)
        4   index = 0
        4   for i in 1:times
        7     for j in eachindex(x)
       21       for k in 1:each[j]
       48         index += 1
       48         rval[index] = x[j]
        -       end
        -     end
        -   end
        4   return(rval)
        - end
        - 
        - """
        - The four argument version substitutes customized ordering for a hard-coded '<'.
        - """
        - function Base.searchsortedfirst(v::AbstractVector, x, lo::Int, hi::Int)
      192     lo = lo-1
      192     hi = hi+1
      192     @inbounds while lo < hi-1
      400         m = (lo+hi)>>>1
      400         if v[m] < x
      160             lo = m
        -         else
      240             hi = m
        -         end
        -     end
      192     return hi
        - end
        - 
        - """
        - The method for two vectors is like R's findinterval.
        - """
        2 Base.searchsortedfirst(v::AbstractVector, x::AbstractVector) = searchsortedfirst(v, x, 1, length(x))
        - function Base.searchsortedfirst(v::AbstractVector, x::AbstractVector, lo::Int, hi::Int)
        2     indices = Vector{typeof(hi)}(length(x))
        2     lo = lo-1
        2     hi = hi+1
        2     n = length(v)
        2     @inbounds for (i,query) in enumerate(x)
        -         # unsorted x, restart left side
       10         @inbounds if lo > 0 && query <= v[lo]
        1             lo = 0
        -         end
        -         # cast out exponentially to get hi to the right of query
       10         jump = 1
       10         @inbounds while true
       17             if hi >= n
        5                 hi = n + 1
        5                 break
        -             end
       12             if query < v[hi]
        5                 break
        -             end
        7             lo = hi
        7             hi = hi + jump
        7             jump = jump * 2
        -         end
        -         # binary search for the exact bin
       10         @inbounds while lo < hi-1
        8             m = (lo+hi)>>>1
        8             @inbounds if query > v[m]
        2                 lo = m
        -             else
        6                 hi = m
        -             end
        -         end
       10         @inbounds indices[i] = hi
       10         lo = hi - 1
        -     end
        2     return(indices)
        - end
        - 
