        - # Groups of functions with a shared signature defined for vectors
        - # https://stat.ethz.ch/R-manual/R-patched/library/methods/html/S4groupGeneric.html
        - # Translated to julia, adding scalar versions of operators
        - # Arith
        - # "+", "-", "*", "^", "%%", "%/%", "/"
        - #const arith_group = [:(+), :(-), :(*), :(/), :(^), :(.+), :(.-), :(.*), :(./), :(.^), :(div), :(mod), :(fld), :(rem)]
        - const arith_group = [:(+), :(-), :(.+), :(.-), :(.*), :(./), :(.^), :(div), :(mod), :(fld), :(rem)] # Just scalar arith for vectors
        - 
        - # Compare
        - # "=="), ">"), "<"), "!="), "<="), ">="
        - const compare_group = [:(.==), :(.>), :(.<), :(.!=), :(.<=), :(.>=)]
        - 
        - # Logic
        - # "&"), "|".
        - const logic_group = [:(&), :(|)]
        - 
        - # Ops
        - # "Arith", "Compare", "Logic"
        - const ops_group = vcat( arith_group, compare_group, logic_group )
        - 
        - # Math
        - # "abs", "sign", "sqrt", "ceiling", "floor", "trunc", "cummax", "cummin", "cumprod", "cumsum", "log", "log10", "log2", "log1p", "acos", "acosh", "asin", "asinh", "atan", "atanh", "exp", "expm1", "cos", "cosh", "sin", "sinh", "tan", "tanh", "gamma", "lgamma", "digamma", "trigamma"
        - const math_group = [:abs, :sign, :sqrt, :ceil, :floor, :trunc, :cummax, :cummin, :cumprod, :cumsum, :log, :log10, :log2, :log1p, :acos, :acosh, :asin, :asinh, :atan, :atanh, :exp, :expm1, :cos, :cosh, :sin, :sinh, :tan, :tanh, :gamma, :lgamma, :digamma, :trigamma]
        - 
        - # Math2
        - # "round", "signif"
        - # leaving out for now
        - 
        - # Summary
        - # "max", "min", "range", "prod", "sum", "any", "all"
        - const summary_group =[:maximum, :minimum, :range, :prod, :sum, :any, :all, :eltype, :unique, :minimum, :maximum, :extrema, :first, :last, :maxabs, :minabs, :any, :all] # sum and prod special
        - 
        - # Complex
        - # "Arg", "Conj", "Im", "Mod", "Re"
        - # leaving out for now
        - 
        - ### Operators, methods that take two arguments and return a modified RLEVector
        - function ^(x::RLEVector,y::Integer) # Necessary to prevent an ambiguity warning
        -   rv = ^(x.runvalues,y)
        -   RLEVector(rv,x.runends)
        - end
        - 
        - .^(x::Base.Irrational{:e}, y::RLEVectors.RLEVector) = .^(x,y) # Ambig fix
        - for op in ops_group
        -     @eval begin
        -         # Rle, Rle
        -         function ($op)(x::RLEVector, y::RLEVector)
        -             length(x) != length(y) && error("RLEVectors must be of the same length for this operation.")
        -             runends = disjoin(x,y)
        -             x_inds = searchsortedfirst(x.runends, runends)
        -             y_inds = searchsortedfirst(y.runends, runends)
        -             runvals = ($op)( x.runvalues[x_inds], y.runvalues[y_inds] )
        -             RLEVector( runvals, runends )
        -         end
        -         # Rle, scalar
        -         ($op){T<:Integer}(x::RLEVector{Bool,T},y::Bool) = RLEVector( ($op)(x.runvalues,y), x.runends ) # Ambig fix
        4         ($op)(x::RLEVector,y::Number) = RLEVector( ($op)(x.runvalues,y), x.runends )
        -         # Number, Rle
        -         ($op){T<:Integer}(y::Bool, x::RLEVector{Bool,T}) = RLEVector( ($op)(y,x.runvalues), x.runends ) # Ambig fix
        1         ($op)(y::Number, x::RLEVector) = RLEVector( ($op)(y,x.runvalues), x.runends )
        -     end
        - end
        - 
        - ## Methods that delegate to the runvalues and return an RLEVector
        - ## Methods that take one argument, an RLEVector, and delegate to rle.runvalues and return an RLEVector
        - for op in math_group
        -   @eval ($op)(x::RLEVector) = RLEVector( ($op)(x.runvalues), x.runends )
        - end
        - 
        - ## Methods that take one argument, an RLEVector, and delegate to rle.runvalues and return something other than an RLEVector
        - for op in setdiff(summary_group,[:sum,:prod])
        3   @eval ($op)(x::RLEVector) = ($op)(x.runvalues)
        - end
        - 
        - ## Methods that take two arguments, delegate to rle.runvalues and return something other than an RLEVector
        2 in{T1,T2<:Integer}(y::T1, x::RLEVector{T1,T2}) = in(y, x.runvalues)
        - 
        - # Defaulting to fun(itr) for prod, sumabs, sumabs2, count
        - for op in [:findmin, :findmax]
        -   @eval begin
        -     function ($op)(x::RLEVector)
        2       m = ($op)(x.runvalues)
        2       (m[1], rfirst(x,m[2]))
        -     end
        -   end
        - end
        - 
        1 indexin(x::RLEVector,y::RLEVector) = RLEVector( indexin(x.runvalues,y), x.runends)
        1 indexin(x::RLEVector,y::AbstractVector) = RLEVector( indexin(x.runvalues,y), x.runends )
        2 indexin(x::AbstractVector,y::RLEVector) = Int[ i == 0 ? 0 : y.runends[i] for i in indexin(x,y.runvalues) ]
        - 
        - function findin(x::RLEVector,y::RLEVector)
        1   runs = findin(x.runvalues,y.runvalues)
        1   re = x.runends
        1   vcat( [ collect( rfirst(x,i):re[i] ) for i in runs ]... )  # hashing in above findin takes the vast majority of the time, don't sweat the time here
        - end
        - 
        - function findin(x::RLEVector,y::UnitRange)
        1   runs = findin(x.runvalues,y)
        1   re = x.runends
        1   vcat( [ collect( rfirst(x,i):re[i] ) for i in runs ]... ) # hashing in above findin takes the vast majority of the time, don't sweat the time here
        - end
        - 
        - function findin(x::RLEVector,y)
        1   runs = findin(x.runvalues,y)
        1   re = x.runends
        1   vcat( [ collect( rfirst(x,i):re[i] ) for i in runs ]... )  # hashing in above findin takes the vast majority of the time, don't sweat the time here
        - end
        - 
        - function findin(x,y::RLEVector)
        1   findin(x,y.runvalues)
        - end
        - 
        - function median(x::RLEVector)
        -     # Superfluous x / 1.0 is to always return a Float64
        2   len = length(x)
        2   len < 2 && return(x.runvalues[1] / 1.0)
        2   sorted = sort(x)
        2   mid = fld(len,2)
        2   mid_run = ind2run(sorted,mid)
        2   if mod(len,2) == 0 && mid == sorted.runends[mid_run] # even numbered and at end of run, avg with next value
        0     median = (sorted.runvalues[mid_run] + sorted.runvalues[mid_run+1]) / 2
        -   else
        2     median = sorted.runvalues[mid_run] / 1.0
        -   end
        2   return(median)
        - end
        - 
        - function sum{T1,T2}(x::RLEVector{T1,T2})
        -   rval = zero(T1)
        -    @simd for i in 1:nrun(x)
        -     @inbounds rval = rval + (x.runvalues[i] * x.runends[i])
        -   end
        -   return(rval)
        - end
        - 
        - function mean{T1,T2}(x::RLEVector{T1,T2})
        -   rval = sum(x) / length(x)
        - end
        - 
